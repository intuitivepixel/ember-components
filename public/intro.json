[{"title":"Introduction to Ember Components","description":"Why and how to use components in Ember?","intro":"","url":"http://example.com/blog/introduction/","markdown":"\n\n##Ember Components\n\n####The web is moving forward with new standards, and so is Ember.js. Embrace Ember Components to lead you to reusable applications\n\n\n####What is a Ember.Component and what is the main difference between a view and a component?\n\n**Quotes from ember website**\n> This is so important to us that we are working closely with the standards bodies to ensure our implementation of components matches the roadmap of the web platform.\n\nAn Ember.View is currently limited to the tags that are created for you by the W3C. But if you wanted to define your own application-specific HTML tags and then implement their behavior using JavaScript? You can't do this actually with a Ember.View. That's exactly what components let you do. In fact, it's such a good idea that the W3C is currently working on the Custom Elements spec. Ember's implementation of components tries to be as closely to the Web Components specification as possible. Once Custom Elements are widely available in browsers, you should be able to easily migrate your Ember components to the W3C standard and have them be usable by other frameworks as well that have adopted the new standard.\n\n*This is so important to us that we are working closely with the standards bodies to ensure our implementation of components matches the roadmap of the web platform.*\n\nAlso important to note is that a Ember.Component is actually a Ember.View (a subclass) but that is completely isolated. Property access in its templates go to the view object and actions are targeted also at the view object. There is no access to the surrounding context or outer controller all contextual information is passed in, which is not the case with a Ember.View which indeed has access to it's surrounding controller, for example inside a view you could do something like this.get('controller') which would give you the controller currently associated with the view.\n\nSo, the main difference besides that components let you create your own tags and in some point in the future when Custom Elements are available also migrate/use those components in other frameworks that will support custom elements, is indeed that at some point an ember component will make a view somewhat obsolete depending on the specific implementation case.\n\nAnd what would be a common example where I would prefer to use a view over a component and vice versa? Following the above this depends clearly on your use cases. But as a rule of thumb, if you need in your view access to it's surrounding controller etc. use a Ember.View, but if you want to isolated the view and pass in only the information that it needs to work making it agnostically of the context and much more reusable, use a Ember.Component.\n\n###Introduction\n\nEmber.Component is one of many new concepts Ember.js has, and it is the way to go if you want to build better and most of all reusable components for your Ember.js applications. If you are already familiar with Ember.View than the concept of Ember.Component should be very clear to you, altough it has it's differences which makes it more appropriate for most implementation cases, where separation of concerns is written in bold.\n\nAs already mentioned Ember.Component extends from Ember.View and therefore inherits all of Ember.View atteibutes and capabilities. But it's the differences to an Ember.View which makes an Ember.Component unique of it's kind. When a Ember.View is used to backup a template or even as a separate view with some kind of functionality, this view has by default access to the context it is rendered into. Imagine you have a Ember.View which is a simple wrapper for the HTML img tag, this view would look something like this:\n\n```\nApp.PlaceHolderImageView = Ember.View.extend({\n  tagName: 'img',\n  attributeBindings: ['src', 'width', 'height']\n  src: 'http://placehold.it/200x200',\n  width: '200',\n  heght: '200'\n});\n```\n\n###Sending actions from inside a component\n\nThe way Ember.Component's work is to be agnostic to other parts of your application, therefore rather then passing in a controller on which you want an action to be called on when something happens in your component, you do it more like in this way:\n\n```\nApp.ApplicationController = Ember.ObjectController.extend({\n  actions: {\n    actionNameOnTheController: function() {\n      console.log('actionNameOnTheController called');\n    }\n  }\n});\n```\n```\n{{some-test action=\"actionNameOnTheController\"}}\n```\n\nAs you can see you set the action attribute to the action name on your controller, and then inside your component you simply call this.sendAction('action'); which will trigger whatever action name you defined earlier:\n\n```\nApp.SomeTestComponent = Ember.Component.extend({\n  click : function(){\n    this.sendAction('action');\n  }\n});\n```\n\nSo now, whenever click is invoked it will send the action actionNameOnTheController to whatever controller is listening to it. And best of all, without knowing nothing about the controller. This is the kind of functionality that makes Ember.Component's reusable in any way.\n","html":"<h2>Ember Components</h2>\n<h4>The web is moving forward with new standards, and so is Ember.js. Embrace Ember Components to lead you to reusable applications</h4>\n<h4>What is a Ember.Component and what is the main difference between a view and a component?</h4>\n<p><strong>Quotes from ember website</strong></p>\n<blockquote>\n<p>This is so important to us that we are working closely with the standards bodies to ensure our implementation of components matches the roadmap of the web platform.</p>\n</blockquote>\n<p>An Ember.View is currently limited to the tags that are created for you by the W3C. But if you wanted to define your own application-specific HTML tags and then implement their behavior using JavaScript? You can&#39;t do this actually with a Ember.View. That&#39;s exactly what components let you do. In fact, it&#39;s such a good idea that the W3C is currently working on the Custom Elements spec. Ember&#39;s implementation of components tries to be as closely to the Web Components specification as possible. Once Custom Elements are widely available in browsers, you should be able to easily migrate your Ember components to the W3C standard and have them be usable by other frameworks as well that have adopted the new standard.</p>\n<p><em>This is so important to us that we are working closely with the standards bodies to ensure our implementation of components matches the roadmap of the web platform.</em></p>\n<p>Also important to note is that a Ember.Component is actually a Ember.View (a subclass) but that is completely isolated. Property access in its templates go to the view object and actions are targeted also at the view object. There is no access to the surrounding context or outer controller all contextual information is passed in, which is not the case with a Ember.View which indeed has access to it&#39;s surrounding controller, for example inside a view you could do something like this.get(&#39;controller&#39;) which would give you the controller currently associated with the view.</p>\n<p>So, the main difference besides that components let you create your own tags and in some point in the future when Custom Elements are available also migrate/use those components in other frameworks that will support custom elements, is indeed that at some point an ember component will make a view somewhat obsolete depending on the specific implementation case.</p>\n<p>And what would be a common example where I would prefer to use a view over a component and vice versa? Following the above this depends clearly on your use cases. But as a rule of thumb, if you need in your view access to it&#39;s surrounding controller etc. use a Ember.View, but if you want to isolated the view and pass in only the information that it needs to work making it agnostically of the context and much more reusable, use a Ember.Component.</p>\n<h3>Introduction</h3>\n<p>Ember.Component is one of many new concepts Ember.js has, and it is the way to go if you want to build better and most of all reusable components for your Ember.js applications. If you are already familiar with Ember.View than the concept of Ember.Component should be very clear to you, altough it has it&#39;s differences which makes it more appropriate for most implementation cases, where separation of concerns is written in bold.</p>\n<p>As already mentioned Ember.Component extends from Ember.View and therefore inherits all of Ember.View atteibutes and capabilities. But it&#39;s the differences to an Ember.View which makes an Ember.Component unique of it&#39;s kind. When a Ember.View is used to backup a template or even as a separate view with some kind of functionality, this view has by default access to the context it is rendered into. Imagine you have a Ember.View which is a simple wrapper for the HTML img tag, this view would look something like this:</p>\n<pre><code>App.PlaceHolderImageView = Ember.View.extend({\n  tagName: &#39;img&#39;,\n  attributeBindings: [&#39;src&#39;, &#39;width&#39;, &#39;height&#39;]\n  src: &#39;http://placehold.it/200x200&#39;,\n  width: &#39;200&#39;,\n  heght: &#39;200&#39;\n});</code></pre>\n<h3>Sending actions from inside a component</h3>\n<p>The way Ember.Component&#39;s work is to be agnostic to other parts of your application, therefore rather then passing in a controller on which you want an action to be called on when something happens in your component, you do it more like in this way:</p>\n<pre><code>App.ApplicationController = Ember.ObjectController.extend({\n  actions: {\n    actionNameOnTheController: function() {\n      console.log(&#39;actionNameOnTheController called&#39;);\n    }\n  }\n});</code></pre>\n<pre><code>{{some-test action=&quot;actionNameOnTheController&quot;}}</code></pre>\n<p>As you can see you set the action attribute to the action name on your controller, and then inside your component you simply call this.sendAction(&#39;action&#39;); which will trigger whatever action name you defined earlier:</p>\n<pre><code>App.SomeTestComponent = Ember.Component.extend({\n  click : function(){\n    this.sendAction(&#39;action&#39;);\n  }\n});</code></pre>\n<p>So now, whenever click is invoked it will send the action actionNameOnTheController to whatever controller is listening to it. And best of all, without knowing nothing about the controller. This is the kind of functionality that makes Ember.Component&#39;s reusable in any way.</p>\n","date":"1970-01-01T00:00:00.000Z","rfc822date":"Thu, 01 Jan 1970 01:00:00 +0100","hasMore":true,"template":"post.hbs"}]